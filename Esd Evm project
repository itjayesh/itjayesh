#include <LPC17xx.h>

/* ===================== LCD Pins ===================== */
#define RS_CTRL 0x08000000   // P0.27
#define EN_CTRL 0x10000000   // P0.28
#define DT_CTRL 0x07800000   // P0.23�P0.26

/* ===================== Keypad Pins ===================== */
#define COL_BASE_BIT 15
#define ROW_BASE_BIT 19
#define COL_MASK (0x0F << COL_BASE_BIT)   // P0.15�P0.18
#define ROW_MASK (0x0F << ROW_BASE_BIT)   // P0.19�P0.22

/* ===================== Globals ===================== */
unsigned long temp1 = 0, temp2 = 0, i;
unsigned char flag1 = 0, flag2 = 0;
unsigned long init_command[] = {0x30,0x30,0x30,0x20,0x28,0x0C,0x01,0x80};

unsigned int count_bjp = 0;
unsigned int count_cong = 0;
unsigned int count_local = 0;
unsigned int count_nota = 0;

/* ===================== Function Prototypes ===================== */
void lcd_write(void);
void port_write(void);
void delay_lcd(unsigned long);
void short_delay(volatile unsigned int d);
void lcd_cmd(unsigned char cmd);
void lcd_char(unsigned char data);
void lcd_init(void);
void lcd_clear(void);
void lcd_puts(const char *str);
void lcd_display_options(void);
void lcd_display_vote(unsigned char key);
void lcd_display_counts(void);
unsigned char keypad_getkey(void);

/* ===================== Main ===================== */
int main(void) {
    SystemInit();

    /* LCD setup */
    LPC_GPIO0->FIODIR |= DT_CTRL | RS_CTRL | EN_CTRL;
    lcd_init();

    /* Keypad setup */
    LPC_PINCON->PINSEL0 &= ~(0xFFFFFFFF);
    LPC_PINCON->PINSEL1 &= ~(0xFFFFFFFF);
    LPC_GPIO0->FIODIR |= COL_MASK;  // Columns output
    LPC_GPIO0->FIODIR &= ~ROW_MASK; // Rows input
    LPC_GPIO0->FIOSET = COL_MASK;   // All columns high

    lcd_display_options();

    while (1) {
        unsigned char key = keypad_getkey();

        if (key != 0xFF) {
            if (key >= 1 && key <= 4) {
                // Update vote count
                if (key == 1) count_bjp++;
                else if (key == 2) count_cong++;
                else if (key == 3) count_local++;
                else if (key == 4) count_nota++;

                // Show whom they voted for
                lcd_display_vote(key);
                delay_lcd(20000000);  // ~2 sec delay
                lcd_display_options(); // Back to menu
            } 
            else if (key == 8) {  // Show vote counts
                lcd_display_counts();
                delay_lcd(30000000);  // ~3 sec delay
                lcd_display_options();
            }
        }
    }
}

/* ===================== LCD Functions ===================== */
void lcd_init(void) {
    flag1 = 0;
    for (i = 0; i < 8; i++) {
        temp1 = init_command[i];
        lcd_write();
        delay_lcd(50000);
    }
    flag1 = 1;
}

void lcd_cmd(unsigned char cmd) {
    flag1 = 0;
    temp1 = cmd;
    lcd_write();
    delay_lcd(30000);
}

void lcd_char(unsigned char data) {
    flag1 = 1;
    temp1 = data;
    lcd_write();
    delay_lcd(30000);
}

void lcd_puts(const char *str) {
    while (*str) lcd_char(*str++);
}

void lcd_clear(void) {
    lcd_cmd(0x01);
    delay_lcd(50000);
}

void lcd_display_options(void) {
    lcd_clear();
    lcd_cmd(0x80);
    lcd_puts("1:BJP 2:Cong");
    lcd_cmd(0xC0);
    lcd_puts("3:Local 4:NOTA");
}

void lcd_display_vote(unsigned char key) {
    lcd_clear();
    lcd_cmd(0x80);
    lcd_puts("You voted:");
    lcd_cmd(0xC0);

    switch (key) {
        case 1: lcd_puts("BJP"); break;
        case 2: lcd_puts("Congress"); break;
        case 3: lcd_puts("Local"); break;
        case 4: lcd_puts("NOTA"); break;
        default: lcd_puts("Invalid"); break;
    }
}

void lcd_display_counts(void) {
    char buf[16];
    lcd_clear();
    lcd_cmd(0x80);
    sprintf(buf, "B:%u C:%u", count_bjp, count_cong);
    lcd_puts(buf);
    lcd_cmd(0xC0);
    sprintf(buf, "L:%u N:%u", count_local, count_nota);
    lcd_puts(buf);
}

void lcd_write(void) {
    flag2 = (flag1 == 1) ? 0 :
            (((temp1 == 0x30) || (temp1 == 0x20)) ? 1 : 0);

    temp2 = temp1 & 0xf0;
    temp2 = temp2 << 19;
    port_write();

    if (!flag2) {
        temp2 = temp1 & 0x0f;
        temp2 = temp2 << 23;
        port_write();
    }
}

void port_write(void) {
    LPC_GPIO0->FIOPIN = temp2;

    if (flag1 == 0)
        LPC_GPIO0->FIOCLR = RS_CTRL;
    else
        LPC_GPIO0->FIOSET = RS_CTRL;

    LPC_GPIO0->FIOSET = EN_CTRL;
    delay_lcd(100);
    LPC_GPIO0->FIOCLR = EN_CTRL;
    delay_lcd(500000);
}

/* ===================== Keypad Functions ===================== */
unsigned char keypad_getkey(void) {
    unsigned int col_idx, row_idx, row_bits;
    unsigned char pressed = 0xFF;  // ? declared at top

    for(col_idx = 0; col_idx < 4; col_idx++) {
        LPC_GPIO0->FIOSET = COL_MASK;
        short_delay(50);
        LPC_GPIO0->FIOCLR = (1 << (COL_BASE_BIT + col_idx));
        short_delay(200);

        row_bits = (LPC_GPIO0->FIOPIN & ROW_MASK) >> ROW_BASE_BIT;

        if(row_bits != 0x0F) {
            for(row_idx = 0; row_idx < 4; row_idx++) {
                if((row_bits & (1 << row_idx)) == 0) {
                    LPC_GPIO0->FIOSET = COL_MASK;
                    pressed = col_idx * 4 + row_idx;
                    if (pressed <= 3)
                        return pressed + 1; // 1�4
                    else if (pressed == 7)
                        return 8; // key '8' ? show counts
                    else
                        return 0xFF;
                }
            }
        }
    }
    return 0xFF; // No key
}

/* ===================== Delays ===================== */
void delay_lcd(unsigned long r1) {
    unsigned long r;
    for (r = 0; r < r1; r++);
}

void short_delay(volatile unsigned int d) {
    while(d--) __NOP();
}
